#!/usr/bin/perl -w

=pod

=head1 NAME

thetop - A 'top' utility for the schwartz

=head1 SYNOPSIS

  thetop [--func FORMAT] [--arg FORMAT] [--sort ARGS] [--delay SECS] [--score-dir DIR]

=head1 DESCRIPTION


=cut

#--------------------------------------#
# Dependencies

use strict;

use Getopt::Long;
use Term::Cap;
use POSIX;

#--------------------------------------#
# Global Variables

use vars qw( $OSPEED );

BEGIN {
    my $termios = POSIX::Termios->new;
    $termios->getattr;
    $OSPEED = $termios->getospeed || 9600;
};

our $TERM = Term::Cap->Tgetent({OSPEED=>$OSPEED});

main();

#--------------------------------------#
# Main Program

sub main {
    my $conf = configure();

    # Start reporting
    while (1) {
        report($conf);
        sleep($conf->{delay});
    }
}

################################################################################

sub configure {
    my ($score_dir, $delay, $func_col, @arg_col, $sort);

    GetOptions('score-dir=s' => \$score_dir,
               'delay|d=s'   => \$delay,
               'func=s'      => \$func_col,
               'arg=s'       => \@arg_col,
               'sort|s=s'    => \$sort,
              );

    # Make sure we know where to find the scoreboard files
    unless ($score_dir) {
        foreach my $d (qw(/var/run /dev/shm /tmp)) {
            if (-e "$d/theschwartz") {
                $score_dir = "$d/theschwartz";
                last;
            }
        }

        die "Can't find scoreboard directory.  Use '--score-dir'\n"
          unless $score_dir;
    }

    # If we got some formatting instructions for the arg column, parse it out
    my %arg_col_by_func;
    if (@arg_col) {
        foreach my $a (@arg_col) {
            if ($a =~ /=/) {
                my ($func, $fmt) = split('=', $a, 2);
                $arg_col_by_func{$func} = $fmt;
            } else {
                $arg_col_by_func{'__ALL__'} = $a;
            }
        }
    }

    # Make sure to give a reasonable default for delay
    $delay ||= 3;

    my $row_width = 100;
    my @columns = (
        [ 'PID',  6  ],
        [ 'FUNC', 40 ],
        [ 'S',    2  ],
        [ 'TIME', 8  ],
        [ 'ARGS', 40 ],
    );
    my $row_format = join(' ', map { '%-'.$_->[1].'.'.$_->[1].'s' } @columns)."\n";
    my @column_labels  = map { $_->[0] } @columns;

    return +{
        score_dir       => $score_dir,
        delay           => $delay,
        arg_col_by_func => \%arg_col_by_func,
        func_col        => $func_col,
        sort            => $sort,
        row_width       => $row_width,
        row_format      => $row_format,
        column_labels   => \@column_labels,
    };
}

sub report {
    my $conf = shift;

    # Find the files available
    opendir(SD, $conf->{score_dir}) or die "Can't read directory '".$conf->{score_dir}."': ".$!."\n";
    my @files = map { $conf->{score_dir}."/$_" } readdir(SD);
    closedir(SD);

    # Grab the data out of them
    my @data;
    my $now = time;
    foreach my $f (@files) {
        next unless $f =~ /scoreboard\.[0-9]+$/;
        open(SF, '<', $f) or die "Can't open score file '$f': $!\n";
        my %dat = map { chomp; split('=', $_, 2) } <SF>;
        close(SF);

        push @data, \%dat;
    }
    my $num_workers = scalar(@data);


    # format rows
    my $header = sprintf("Workers: %4d total ", $num_workers);
    $header .= sprintf('%'.($conf->{row_width} - length($header))."s\n\n", scalar localtime($now));
    $header .= sprintf($conf->{row_format}, @{ $conf->{column_labels} });

    my @rows = ();
    foreach my $d (sort { order_by($conf->{sort}, $a, $b) } @data) {
        my $formatted_funcname = format_funcname($d->{funcname}, $conf->{func_col});

        my @column_values = (
            $d->{pid},
            $formatted_funcname,
            ($d->{done} ? 'S' : 'R'),
            format_time($d->{started}, $d->{done}, $now),
            format_arg($d->{arg}, $conf->{arg_col_by_func}, $d->{funcname}, $formatted_funcname),
        );
        push @rows, sprintf($conf->{row_format}, @column_values);
    }


    # clear screen and print
    clear_screen();
    print $header;
    print join '', @rows;
}

sub order_by {
    my ($sort, $a, $b) = @_;

    if ($sort) {

    } else {
        # Default to push running tasks to the top
        return ($a->{done}||0) <=> ($b->{done}||0) ||
               ($a->{started}||0) <=> ($b->{started}||0);
    }
}

sub format_funcname {
    my ($funcname, $fmt) = @_;
    my $val;

    if ($fmt) {
        if ($fmt eq 'trim') {
            $val = $funcname;
            $val =~ s/^.+:://g;
        } else {
            $funcname =~ /($fmt)/;
            $val = $1;
        }
    } else {
        $val = $funcname;
    }

    return $val;
}

sub format_time {
    my ($started, $done, $now) = @_;
    my $secs = ($done||$now) - $started;

    if ($secs < 60) {
        return sprintf("%02d:%02d", 0, $secs);
    } elsif ($secs < 3600) {
        my $min = int($secs/60);
        $secs = $secs%60;
        return sprintf("%02d:%02d", $min, $secs);
    } else {
        my $hr  = int($secs/60/60);
        my $min = int($secs/60%60);
        $secs = $secs%60;
        return sprintf("%d:%02d:%02d", $hr, $min, $secs);
    }
}

## Format the arguments by interpreting the args as either a hash or an array
## and printing out the appropriate element.

sub format_arg {
    my ($arg, $arg_col_by_func, $funcname, $formatted_funcname) = @_;
    my $arg_array = [split(',', $arg||'')];

    my $fmt;
    if ($arg_col_by_func) {
        $fmt = ($arg_col_by_func->{$formatted_funcname}  ||
                   $arg_col_by_func->{$funcname} ||
                   $arg_col_by_func->{'__ALL__'});
    }

    my $val;
    if (!$fmt) {
        $val = $arg;
    } elsif ($fmt =~ /^[0-9]+$/) {
        # If its a number treat the args as an array
        my $arg_array = [split(',', $arg||'')];
        $val = $arg_array->[$fmt];
    } else {
        # otherwise, treat the args as a hash
        # Compensate for odd numbers of args
        my $arg_array = [split(',', $arg||'')];
        push @$arg_array, undef if scalar(@$arg_array) % 2;

        my %h = @$arg_array;
        $val = $h{$fmt};
    }

    return $val;
}

sub clear_screen {
    $TERM->Tputs('cl', 1, \*STDOUT);
}
